# Generated by Selenium IDE
import pytest
import time
import json
import os
import sys
sys.path.append('/oracle/python-libs')
GENERAR_REPORTE = os.getenv("GENERAR_REPORTE", "True").lower() == "true"
from dotenv import load_dotenv
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from selenium.webdriver.support.wait import WebDriverWait
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities

#task
from datetime import datetime
from abilities.navegar import iniciar_navegador
from task.login import Login
from task.navMenu import NavMenu
from task.consulta import Consulta
from task.validarResultados import resultados
from utils.descifrar_contrasena import obtener_contrasena
from utils.captura import Capturas  # <-- Capturas importada
from utils.reportes.reporte_word import ReporteDocumento
from utils.reportes.word import ReporteManager
from utils.errores_telegram.envio_error_telegram import error_persistencia,enviar_a_queue, convertir_imagen_a_base64
from urllib.parse import urlparse
# Cargar las variables de entorno desde el archivo .env
load_dotenv()
#load_dotenv("/env/modulo_de_gestion/.envSimuladorRegla")

# Acceder a las variables definidas en el archivo .env
BASE_URL = os.getenv('BASE_URL')
USUARIO = os.getenv('USUARIO')
CONTRASENA = obtener_contrasena()

# Validar si las variables de entorno están definidas
if not BASE_URL or not USUARIO or not CONTRASENA:
    raise ValueError("BASE_URL, USUARIO o CONTRASENA no están definidas en el archivo .env")

# Fixture para aceptar el parámetro de la orden
@pytest.fixture
def orden(request):
    return request.config.getoption("--orden")

def obtener_apuntamiento():
    try:
        base_url = os.getenv("BASE_URL", "")
        parsed_url = urlparse(base_url)
        return parsed_url.hostname or "sin_apuntamiento"
    except Exception:
        return "sin_apuntamiento"
    
class Testsimulador_regla():
  @classmethod
  def setup_class(cls):
    Capturas.limpiar_subcarpeta("simulador_regla")
    if GENERAR_REPORTE:
      cls.reporte = ReporteManager.obtener("simulador_regla")
    else:
      cls.reporte = None

  def setup_method(self, method):
    time.sleep(5)
    self.driver = iniciar_navegador()
    self.vars = {}
    self.base_url = os.getenv("BASE_URL")
    self.usuario = os.getenv("USUARIO")
    self.contrasena = os.getenv("CONTRASENA")
    self.reporte = self.__class__.reporte  # <- esta línea es la clave
    self.inicio_test = time.time()
    
  def teardown_method(self, method):
      fecha = datetime.now().strftime("%d-%m-%Y")
      hora = datetime.now().strftime("%H:%M:%S")
    # Calcular duración del test al inicio del teardown
      duracion_total = time.time() - self.inicio_test

      # Ejecutar error_persistencia
      try:
        wait = WebDriverWait(self.driver, 10)
        error_persistencia(self.driver, wait, self.reporte, contexto="crear simulador regla")
      except Exception as e:
        print(f"[ERROR] en error_persistencia: {e}")

      # Control de timeout
      if duracion_total > 60:
        print(f"[ALERTA] Test demoró {duracion_total:.2f} segundos. Enviando alerta...")
        try:
          ruta_timeout = Capturas.tomar_pantallazo(self.driver, "timeout_test", "", "Timeout")
          imagen_base64 = convertir_imagen_a_base64(ruta_timeout)
          mensaje=f"PRUEBAS\nFecha y hora: {fecha} / {hora}\nNodo: {BASE_URL}\nError: *Timeout Simulador Regla*\nDescripción Error: Test superó tiempo esperado en {BASE_URL} (Duración: {duracion_total:.2f}s"
          enviar_a_queue("queue_telegram", mensaje, imagen_base64)
        except Exception as e:
          print(f"[ERROR] Al enviar alerta de timeout: {e}")

      # Cierre del driver
      if self.driver:
        self.driver.quit()
        
  @classmethod
  def teardown_class(cls):
    # Guarda todos los reportes que el manager tenga en memoria
    ReporteManager.guardar_todos()

  def test_caso1(self, orden):
    fecha = datetime.now().strftime("%d-%m-%Y")
    hora = datetime.now().strftime("%H:%M:%S")
    # Abrir el archivo de órdenes si no se ha pasado un orden específico
    
    if orden is None:
      with open("utils/txt/orders_simulador_regla.txt", "r") as f:
        ordenes = f.readlines()
    else:
      ordenes = [orden]

    for orden in ordenes:
      orden = orden.strip()
      if not orden:
        print("Se encontró una línea vacía en el archivo de órdenes, se omite esta línea.")
        continue

    # Usar la URL base de las variables de entorno
    time.sleep(5)
    self.driver.get(self.base_url)
    self.driver.set_window_size(1276, 672)
    ruta1 = Capturas.tomar_pantallazo(self.driver, "abre_navegador","simulador_regla", "Inicio")
    if self.reporte:
      self.reporte.agregar_evidencia("Abre el Navegador", ruta1)

    # LOGIN
    login = Login(self.reporte, self.driver, USUARIO, CONTRASENA)
    rutas_login, tipoRed_element = login.ingresar()
    if GENERAR_REPORTE:
      for idx, ruta2 in enumerate(rutas_login, 1):
        self.reporte.agregar_evidencia(f"Login", ruta2)


    # Guardar el tipoRed_element para validación posterior
    self.vars["tipoRed"] = tipoRed_element
   
    #validacion modulo
    if self.driver.execute_script("return (arguments[0] !== null)", self.vars["tipoRed"]): #true

      self.driver.find_element(By.ID, "tipoRed").click()
      dropdown = self.driver.find_element(By.ID, "tipoRed")
      dropdown.find_element(By.XPATH, "//option[. = 'Operaciones']").click()

      try:
        # Hacer clic en el botón "Submit"
        self.driver.find_element(By.ID, "Submit").click()
        time.sleep(10)
        # Validar error de ingreso
        print("paso el submit")
        try:
            self.vars["errorIngreso"] = self.driver.execute_script(
                "return !!document.querySelector('#DvActividad > table > tbody > tr:nth-child(3) > td > b > font')?.textContent.trim();"
            )
            if self.vars["errorIngreso"]:
                self.vars["valueIngreso"] = self.driver.find_element(
                    By.XPATH, "//div[@id='DvActividad']/table/tbody/tr[3]/td/b/font"
                ).text
                ruta3 = Capturas.tomar_pantallazo(self.driver, "Error_inicio_sesion","simulador_regla", "Error")
                apuntamiento = obtener_apuntamiento()
                if self.reporte:
                  self.reporte.agregar_evidencia("Error Inicio Sesión", ruta3)
                  print(f"Error: {self.vars['valueIngreso']}")
                  imagen_base64 = convertir_imagen_a_base64(ruta3)
                  mensaje=f"PRUEBAS\nFecha y hora: {fecha} / {hora}\nNodo: {apuntamiento}\nError: **Ingreso**\nDescripción Error: Error en el ingreso en el nodo {apuntamiento}",
                  enviar_a_queue("queue_telegram", mensaje, imagen_base64)
                return  # Salir del método si hay error
        except Exception as e:
          print("Error durante la validación de ingreso:", e)
          
        #NavMenu
        time.sleep(5)

        navegacion_menu = NavMenu(self.reporte, self.driver) # Si tu clase NavMenu no necesita el driver en el constructor
        rutas_navegacion = navegacion_menu.menu_simulador_regla()
        #rutas_navegacion = navegacion_menu.menu_simulador_regla(self.driver)
        if GENERAR_REPORTE:
            for idx, ruta in enumerate(rutas_navegacion, 1):
                self.reporte.agregar_evidencia(f"Navegación", ruta)
                
        time.sleep(2)

        # CONSULTA
        consultaOT = Consulta(self.reporte, self.driver)
        
        ruta_archivo = os.path.join(os.path.dirname(__file__), '..', 'utils', 'txt', 'orders_simulador_regla.txt')
        ruta_archivo = os.path.abspath(ruta_archivo)
        # Leer las órdenes desde el archivo
        with open(ruta_archivo, "r") as archivo:
          ordenes = [line.strip() for line in archivo if line.strip()]

        # Ejecutar la consulta por cada orden y capturar evidencias
        for idx, orden in enumerate(ordenes, 1):
            rutas_consulta = consultaOT.consulta_simulador_regla(orden)
            if GENERAR_REPORTE and rutas_consulta:
                for idy, ruta in enumerate(rutas_consulta, 1):
                    self.reporte.agregar_evidencia(f"Consulta Orden {orden}", ruta)

        time.sleep(5) 

        #RESULTADOS
        resultado= resultados(self.reporte, self.driver)
        rutas_resultados = resultado.resultados_simulador_regla()
        if GENERAR_REPORTE:
            for idx, ruta in enumerate(rutas_resultados, 1):
                self.reporte.agregar_evidencia(f"Resultados", ruta)
    

      except Exception as e:
        print("Error durante la validación de ingreso:", e)
      except TimeoutException as te:
        print("Error de tiempo de espera:", te)
      except NoSuchElementException as nse:
        print("Error: Elemento no encontrado:", nse)
      except Exception as e:
        print("Error desconocido:", e)

    else: #false
      try:
        time.sleep(2)

        # Hacer clic en el botón "Submit"
        # Encuentra el elemento
        submit_button = self.driver.find_element(By.ID, "Submit")
        # Realiza un doble clic
        ActionChains(self.driver).double_click(submit_button).perform()
        time.sleep(10)

        # Validar error de ingreso
        try:
            self.vars["errorIngreso"] = self.driver.execute_script(
                "return !!document.querySelector('#DvActividad > table > tbody > tr:nth-child(3) > td > b > font')?.textContent.trim();"
            )
            if self.vars["errorIngreso"]:
                self.vars["valueIngreso"] = self.driver.find_element(
                    By.XPATH, "//div[@id='DvActividad']/table/tbody/tr[3]/td/b/font"
                ).text
                ruta3 = Capturas.tomar_pantallazo(self.driver, "Error_inicio_sesion","simulador_regla", "Error")
                apuntamiento = obtener_apuntamiento()
                imagen_base64 = convertir_imagen_a_base64(ruta3)
                mensaje=f"PRUEBAS\nFecha y hora: {fecha} / {hora}\nNodo: {apuntamiento}\nError: **Ingreso**\nDescripción Error: Error en el ingreso en el nodo {apuntamiento}",
                enviar_a_queue("queue_telegram", mensaje, imagen_base64)
                if self.reporte:
                  self.reporte.agregar_evidencia("Error Inicio Sesión", ruta3)
                  print(f"Error: {self.vars['valueIngreso']}")
                  
                return  # Salir del método si hay error
        except Exception as e:
            print("Error durante la validación de ingreso:", e)
            

        #NavMenu
        time.sleep(5)
        navegacion_menu = NavMenu(self.reporte,self.driver)  # Si tu clase NavMenu no necesita el driver en el constructor
        rutas_navegacion = navegacion_menu.menu_simulador_regla() 
        if GENERAR_REPORTE:
            for idx, ruta in enumerate(rutas_navegacion, 1):
                self.reporte.agregar_evidencia(f"Navegación", ruta)
        time.sleep(2)

        # CONSULTA
        consultaOT = Consulta(self.reporte, self.driver)
        
        ruta_archivo = os.path.join(os.path.dirname(__file__), '..', 'utils', 'txt', 'orders_simulador_regla.txt')
        ruta_archivo = os.path.abspath(ruta_archivo)
        # Leer las órdenes desde el archivo
        with open(ruta_archivo, "r") as archivo:
          ordenes = [line.strip() for line in archivo if line.strip()]

        for idx, orden in enumerate(ordenes, 1):
          rutas_consulta = consultaOT.consulta_simulador_regla(orden)  # <-- Solo pasas 'orden'
          if GENERAR_REPORTE and rutas_consulta:
              for idy, ruta in enumerate(rutas_consulta, 1):
                  self.reporte.agregar_evidencia(f"Consulta Orden {orden}", ruta)

        time.sleep(5) 
        
        #RESULTADOS
        resultado= resultados(self.reporte, self.driver)
        rutas_resultados = resultado.resultados_simulador_regla()
        if GENERAR_REPORTE:
            for idx, ruta in enumerate(rutas_resultados, 1):
                self.reporte.agregar_evidencia(f"Resultados", ruta)

      except Exception as e:
        print("Error durante la validación de ingreso:", e)
      except TimeoutException as te:
        print("Error de tiempo de espera:", te)
      except NoSuchElementException as nse:
        print("Error: Elemento no encontrado:", nse)
      except Exception as e:
        print("Error desconocido:", e)